<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç«æŸ´äººæ¸¸æˆ - å¿«é€Ÿæµ‹è¯•</title>
    <style>
        body { margin: 0; background: #222; font-family: Arial; color: white; }
        #status { padding: 10px; background: #333; margin: 10px; border-radius: 5px; }
        #gameContainer { display: flex; justify-content: center; padding: 10px; }
        canvas { border: 3px solid #fff; background: linear-gradient(180deg, #87CEEB 0%, #B0E0E6 100%); }
        .success { color: #0f0; }
        .error { color: #f00; }
        .warning { color: #ff0; }
        button { padding: 8px 16px; margin: 5px; cursor: pointer; background: #444; color: white; border: 1px solid #666; }
        button:hover { background: #666; }
    </style>
</head>
<body>
    <div id="status">åˆå§‹åŒ–ä¸­...</div>
    <div id="gameContainer">
        <canvas id="gameCanvas" width="600" height="400"></canvas>
    </div>
    <div style="text-align: center; margin: 10px;">
        <button onclick="testGame()">ğŸ® æµ‹è¯•æ¸¸æˆ</button>
        <button onclick="testFullscreen()">ğŸ–¥ï¸ æµ‹è¯•å…¨å±</button>
        <button onclick="testKeyboard()">âŒ¨ï¸ æµ‹è¯•é”®ç›˜</button>
    </div>

    <script>
        const status = document.getElementById('status');
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const keys = {};

        function updateStatus(msg, type = 'normal') {
            const color = type === 'success' ? '#0f0' : type === 'error' ? '#f00' : type === 'warning' ? '#ff0' : '#fff';
            status.innerHTML += `<div style="color: ${color}">${msg}</div>`;
            console.log(msg);
        }

        // æµ‹è¯•1: åŸºç¡€ç¯å¢ƒ
        function testEnvironment() {
            status.innerHTML = '';
            updateStatus('=== ç¯å¢ƒæµ‹è¯• ===');

            if (!canvas) {
                updateStatus('âŒ Canvasæœªæ‰¾åˆ°', 'error');
                return false;
            }
            updateStatus('âœ… Canvasæ‰¾åˆ°', 'success');

            if (!ctx) {
                updateStatus('âŒ Canvasä¸Šä¸‹æ–‡æœªåˆ›å»º', 'error');
                return false;
            }
            updateStatus('âœ… Canvasä¸Šä¸‹æ–‡åˆ›å»ºæˆåŠŸ', 'success');

            updateStatus(`Canvaså°ºå¯¸: ${canvas.width}x${canvas.height}`, 'success');
            return true;
        }

        // æµ‹è¯•2: ç»˜åˆ¶èƒŒæ™¯
        function testBackground() {
            updateStatus('=== èƒŒæ™¯ç»˜åˆ¶æµ‹è¯• ===');
            try {
                // å¤©ç©º
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#B0E0E6');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // å¤ªé˜³
                ctx.beginPath();
                ctx.arc(550, 60, 15, 0, Math.PI * 2);
                ctx.fillStyle = '#FFD700';
                ctx.fill();

                // äº‘æœµ
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.beginPath(); ctx.arc(100, 70, 15, 0, Math.PI * 2);
                ctx.arc(112, 65, 18, 0, Math.PI * 2);
                ctx.arc(124, 70, 15, 0, Math.PI * 2);
                ctx.fill();

                // åœ°é¢
                const groundY = canvas.height - 80;
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, groundY, canvas.width, 80);

                updateStatus('âœ… èƒŒæ™¯ç»˜åˆ¶æˆåŠŸ', 'success');
                return true;
            } catch(e) {
                updateStatus(`âŒ èƒŒæ™¯ç»˜åˆ¶å¤±è´¥: ${e.message}`, 'error');
                return false;
            }
        }

        // æµ‹è¯•3: ç»˜åˆ¶ç«æŸ´äºº
        function drawStickman(x, y, color) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 3;
            ctx.lineCap = 'round';

            // å¤´
            ctx.beginPath();
            ctx.arc(x, y + 8, 8, 0, Math.PI * 2);
            ctx.stroke();

            // èº«ä½“
            ctx.beginPath();
            ctx.moveTo(x, y + 15);
            ctx.lineTo(x, y + 40);
            ctx.stroke();

            // è…¿
            ctx.beginPath();
            ctx.moveTo(x, y + 40);
            ctx.lineTo(x - 6, y + 60);
            ctx.moveTo(x, y + 40);
            ctx.lineTo(x + 6, y + 60);
            ctx.stroke();

            // æ‰‹è‡‚
            ctx.beginPath();
            ctx.moveTo(x, y + 20);
            ctx.lineTo(x + 12, y + 20);
            ctx.moveTo(x, y + 20);
            ctx.lineTo(x - 8, y + 23);
            ctx.stroke();
        }

        function testCharacters() {
            updateStatus('=== è§’è‰²ç»˜åˆ¶æµ‹è¯• ===');
            try {
                drawStickman(200, 150, '#ff6b6b'); // ç©å®¶1
                drawStickman(400, 150, '#4dabf7'); // ç©å®¶2
                updateStatus('âœ… ç«æŸ´äººç»˜åˆ¶æˆåŠŸ', 'success');
                return true;
            } catch(e) {
                updateStatus(`âŒ è§’è‰²ç»˜åˆ¶å¤±è´¥: ${e.message}`, 'error');
                return false;
            }
        }

        // æµ‹è¯•4: åŠ¨ç”»å¾ªç¯
        let animRunning = false;
        let animX = 200;
        let animDir = 1;

        function testAnimation() {
            updateStatus('=== åŠ¨ç”»æµ‹è¯• ===');
            animRunning = true;

            function animate() {
                if (!animRunning) return;

                // é‡ç»˜èƒŒæ™¯
                const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#B0E0E6');
                ctx.fillStyle = gradient;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // åœ°é¢
                ctx.fillStyle = '#654321';
                ctx.fillRect(0, canvas.height - 80, canvas.width, 80);

                // ç§»åŠ¨çš„ç«æŸ´äºº
                animX += animDir * 2;
                if (animX > 400 || animX < 200) animDir *= -1;

                drawStickman(animX, 150, '#ff6b6b');
                drawStickman(350, 150, '#4dabf7');

                // æ˜¾ç¤ºçŠ¶æ€
                ctx.fillStyle = 'white';
                ctx.font = '14px Arial';
                ctx.fillText(`ä½ç½®: ${animX}`, 10, 20);
                ctx.fillText('åŠ¨ç”»è¿è¡Œä¸­...', 10, 40);

                requestAnimationFrame(animate);
            }

            animate();
            updateStatus('âœ… åŠ¨ç”»å¼€å§‹è¿è¡Œ', 'success');
            updateStatus('ğŸ’¡ å¦‚æœçœ‹åˆ°ç«æŸ´äººç§»åŠ¨ï¼Œè¯´æ˜ä¸€åˆ‡æ­£å¸¸ï¼', 'warning');
        }

        // æµ‹è¯•5: é”®ç›˜è¾“å…¥
        function testKeyboard() {
            updateStatus('=== é”®ç›˜æµ‹è¯• ===');
            updateStatus('è¯·æŒ‰ä»»æ„æ–¹å‘é”®æˆ–WASDæµ‹è¯•...', 'warning');

            const testKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'w', 'a', 's', 'd'];
            let detected = false;

            function keyHandler(e) {
                if (testKeys.includes(e.key) && !detected) {
                    detected = true;
                    updateStatus(`âœ… æ£€æµ‹åˆ°æŒ‰é”®: ${e.key}`, 'success');
                    window.removeEventListener('keydown', keyHandler);
                }
            }

            window.addEventListener('keydown', keyHandler);
            setTimeout(() => {
                if (!detected) {
                    updateStatus('âš ï¸ æœªæ£€æµ‹åˆ°æŒ‰é”®äº‹ä»¶', 'warning');
                    window.removeEventListener('keydown', keyHandler);
                }
            }, 3000);
        }

        // æµ‹è¯•6: å…¨å±åŠŸèƒ½
        function testFullscreen() {
            updateStatus('=== å…¨å±æµ‹è¯• ===');
            try {
                const elem = document.documentElement;
                if (!document.fullscreenElement) {
                    elem.requestFullscreen().then(() => {
                        updateStatus('âœ… å…¨å±æˆåŠŸ', 'success');
                    }).catch(e => {
                        updateStatus(`âŒ å…¨å±å¤±è´¥: ${e.message}`, 'error');
                    });
                } else {
                    document.exitFullscreen();
                    updateStatus('âœ… é€€å‡ºå…¨å±', 'success');
                }
            } catch(e) {
                updateStatus(`âŒ å…¨å±åŠŸèƒ½é”™è¯¯: ${e.message}`, 'error');
            }
        }

        // å®Œæ•´æµ‹è¯•æµç¨‹
        function testGame() {
            if (!testEnvironment()) return;
            if (!testBackground()) return;
            if (!testCharacters()) return;

            updateStatus('=== å®Œæ•´æµ‹è¯•æ€»ç»“ ===');
            updateStatus('ğŸ‰ å¦‚æœçœ‹åˆ°èƒŒæ™¯å’Œä¸¤ä¸ªç«æŸ´äººï¼Œè¯´æ˜æ¸¸æˆæ ¸å¿ƒæ­£å¸¸ï¼', 'success');
            updateStatus('ğŸ’¡ ç‚¹å‡»"æµ‹è¯•å…¨å±"éªŒè¯å…¨å±åŠŸèƒ½', 'warning');
            updateStatus('ğŸ’¡ ç‚¹å‡»"æµ‹è¯•é”®ç›˜"éªŒè¯æŒ‰é”®è¾“å…¥', 'warning');

            testAnimation();
        }

        // é”®ç›˜äº‹ä»¶ç›‘å¬
        window.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            keys[e.key.toLowerCase()] = true;
        });

        window.addEventListener('keyup', (e) => {
            keys[e.key] = false;
            keys[e.key.toLowerCase()] = false;
        });

        // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨æµ‹è¯•
        window.addEventListener('load', () => {
            updateStatus('ğŸ”¥ ç«æŸ´äººæ¸¸æˆå¿«é€Ÿæµ‹è¯•å·¥å…·');
            updateStatus('ç‚¹å‡»"æµ‹è¯•æ¸¸æˆ"æŒ‰é’®å¼€å§‹å®Œæ•´æµ‹è¯•');
            updateStatus('æˆ–ç›´æ¥ç‚¹å‡»ä¸‹é¢çš„æŒ‰é’®è¿›è¡Œå•é¡¹æµ‹è¯•');
        });
    </script>
</body>
</html>